import os
import ccxt
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import asyncio
from telegram import Bot
from telegram.error import TelegramError
from scipy.signal import argrelextrema
import config  # Import the config module

def fetch_binance_data(symbol, timeframe='8h', limit=100):
    try:
        binance = ccxt.binance()
        ohlcv = binance.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        data = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        data['timestamp'] = pd.to_datetime(data['timestamp'], unit='ms')
        return data
    except Exception as e:
        print(f"Error fetching data: {e}")
        return pd.DataFrame()

def calculate_trendlines(data, ignore_last=5):
    data['high'] = data['high'].astype(float)
    data['low'] = data['low'].astype(float)

    window_size = 10
    valid_data = data.iloc[:-ignore_last].copy()  # Ignore the last few candles and create a copy
    valid_data['peaks'] = valid_data.iloc[argrelextrema(valid_data['high'].values, np.greater_equal, order=window_size)[0]]['high']
    valid_data['troughs'] = valid_data.iloc[argrelextrema(valid_data['low'].values, np.less_equal, order=window_size)[0]]['low']

    peaks = valid_data.dropna(subset=['peaks'])
    troughs = valid_data.dropna(subset=['troughs'])

    if len(peaks) < 2 or len(troughs) < 2:
        return None, None

    # Use the two most recent highest and lowest points excluding the ignored candles
    recent_peaks = peaks.tail(2)
    recent_troughs = troughs.tail(2)

    if len(recent_peaks) < 2 or len(recent_troughs) < 2:
        return None, None

    # Fit trendlines to the most recent peaks and troughs
    x_peaks = recent_peaks.index
    y_peaks = recent_peaks['peaks'].values
    fit_peaks = np.polyfit(x_peaks, y_peaks, 1)
    trendline_peaks = np.polyval(fit_peaks, data.index)

    x_troughs = recent_troughs.index
    y_troughs = recent_troughs['troughs'].values
    fit_troughs = np.polyfit(x_troughs, y_troughs, 1)
    trendline_troughs = np.polyval(fit_troughs, data.index)

    return trendline_peaks, trendline_troughs

def detect_breakout(data, resistance):
    breakout = data[data['close'] > resistance]
    return breakout

def plot_trendlines(data, trendline_peaks, trendline_troughs, breakout, filename='triangle_breakout.png'):
    plt.figure(figsize=(12, 6))
    plt.plot(data['timestamp'], data['close'], label='Close Price')
    plt.plot(data['timestamp'], trendline_peaks, label='Resistance Trendline', linestyle='--', color='red')
    plt.plot(data['timestamp'], trendline_troughs, label='Support Trendline', linestyle='--', color='green')
    plt.scatter(breakout['timestamp'], breakout['close'], color='blue', label='Breakout Points')
    plt.xlabel('Timestamp')
    plt.ylabel('Price')
    plt.legend()
    plt.title('Ascending Triangle Breakout Detection')
    plt.savefig(filename)
    plt.show()

async def send_image_to_telegram(filename, token, chat_id):
    bot = Bot(token=token)
    try:
        with open(filename, 'rb') as photo:
            await bot.send_photo(chat_id=chat_id, photo=photo)
    except TelegramError as e:
        print(f"Error sending image to Telegram: {e}")

def main():
    symbol = 'BTC/USDT'
    timeframe = '8h'
    token = config.TELEGRAM_TOKEN
    chat_id = config.TELEGRAM_CHAT_ID
    
    data = fetch_binance_data(symbol, timeframe)
    if data.empty:
        print("No data fetched.")
        return

    trendline_peaks, trendline_troughs = calculate_trendlines(data, ignore_last=5)
    if trendline_peaks is None or trendline_troughs is None:
        print("Not enough data to calculate trendlines.")
        return

    resistance = trendline_peaks[-1]
    breakout = detect_breakout(data, resistance)
    filename = 'triangle_breakout.png'
    plot_trendlines(data, trendline_peaks, trendline_troughs, breakout, filename)
    
    asyncio.run(send_image_to_telegram(filename, token, chat_id))

if __name__ == "__main__":
    main()