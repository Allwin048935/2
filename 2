import ccxt
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import asyncio
from telegram import Bot
from telegram.error import TelegramError
from scipy.signal import argrelextrema
import config

def fetch_binance_data(symbol, timeframe='5m', limit=100):
    try:
        binance = ccxt.binance()
        ohlcv = binance.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        data = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        data['timestamp'] = pd.to_datetime(data['timestamp'], unit='ms')
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return pd.DataFrame()

def calculate_trendlines(data, ignore_last=5):
    data['high'] = data['high'].astype(float)
    data['low'] = data['low'].astype(float)

    window_size = 10
    valid_data = data.iloc[:-ignore_last].copy()  # Ignore the last few candles and create a copy
    valid_data['peaks'] = valid_data.iloc[argrelextrema(valid_data['high'].values, np.greater_equal, order=window_size)[0]]['high']
    valid_data['troughs'] = valid_data.iloc[argrelextrema(valid_data['low'].values, np.less_equal, order=window_size)[0]]['low']

    peaks = valid_data.dropna(subset=['peaks'])
    troughs = valid_data.dropna(subset=['troughs'])

    if len(peaks) < 2 or len(troughs) < 2:
        return None, None

    x_peaks = peaks.index.values[-2:]
    y_peaks = peaks['peaks'].values[-2:]
    fit_peaks = np.polyfit(x_peaks, y_peaks, 1)
    trendline_peaks = np.polyval(fit_peaks, np.arange(len(data)))

    x_troughs = troughs.index.values[-2:]
    y_troughs = troughs['troughs'].values[-2:]
    fit_troughs = np.polyfit(x_troughs, y_troughs, 1)
    trendline_troughs = np.polyval(fit_troughs, np.arange(len(data)))

    return trendline_peaks, trendline_troughs

def detect_breakout_breakdown(data, trendline_peaks, trendline_troughs):
    breakout = data[data['close'] > trendline_peaks]
    breakdown = data[data['close'] < trendline_troughs]
    return breakout, breakdown

def plot_trendlines(data, trendline_peaks, trendline_troughs, breakout, breakdown, symbol, filename):
    plt.figure(figsize=(12, 6))
    plt.plot(data['timestamp'], data['close'], label='Close Price')
    plt.plot(data['timestamp'], trendline_peaks, label='Resistance Trendline', linestyle='--', color='red')
    plt.plot(data['timestamp'], trendline_troughs, label='Support Trendline', linestyle='--', color='green')
    plt.scatter(breakout['timestamp'], breakout['close'], color='blue', label='Breakout Points')
    plt.scatter(breakdown['timestamp'], breakdown['close'], color='orange', label='Breakdown Points')
    plt.xlabel('Timestamp')
    plt.ylabel('Price')
    plt.legend()
    plt.title(f'Triangle Breakout/Breakdown Detection for {symbol}')
    plt.savefig(filename)
    plt.close()

async def send_image_to_telegram(filename, token, chat_id):
    bot = Bot(token=token)
    try:
        with open(filename, 'rb') as photo:
            await bot.send_photo(chat_id=chat_id, photo=photo)
    except TelegramError as e:
        print(f"Error sending image to Telegram: {e}")

async def check_for_breakouts_and_breakdowns(symbol, timeframe, token, chat_id):
    data = fetch_binance_data(symbol, timeframe)
    if data.empty:
        print(f"No data fetched for {symbol}.")
        return

    trendline_peaks, trendline_troughs = calculate_trendlines(data)
    if trendline_peaks is None or trendline_troughs is None:
        print(f"Not enough data to calculate trendlines for {symbol}.")
        return

    breakout, breakdown = detect_breakout_breakdown(data, trendline_peaks, trendline_troughs)
    if not breakout.empty or not breakdown.empty:
        filename = f'triangle_breakout_breakdown_{symbol.replace("/", "_")}.png'
        plot_trendlines(data, trendline_peaks, trendline_troughs, breakout, breakdown, symbol, filename)
        await send_image_to_telegram(filename, token, chat_id)

async def main():
    symbols = ['BTC/USDT', 'ETH/USDT', 'AAVE/USDT', 'ACE/USDT', 'ACH/USDT', 'ADA/USDT', 'AEVO/USDT',
               'AGLD/USDT', 'ALGO/USDT', 'ALICE/USDT', 'ALPHA/USDT', 'ALT/USDT', 'AMB/USDT', 'APT/USDT',
               'ARB/USDT', 'ARK/USDT', 'ARPA/USDT', 'AR/USDT', 'ASTR/USDT', 'ATA/USDT', 'ATOM/USDT',
               'AUCTION/USDT', 'AVAX/USDT', 'AXL/USDT', 'AXS/USDT', 'BADGER/USDT', 'BAKE/USDT', 'BAL/USDT',
               'BAND/USDT', 'BAT/USDT', 'BB/USDT']  # List of symbols
    timeframe = '5m'
    token = config.TELEGRAM_BOT_TOKEN
    chat_id = config.TELEGRAM_CHAT_ID

    while True:
        print("Checking for breakouts and breakdowns...")
        tasks = [check_for_breakouts_and_breakdowns(symbol, timeframe, token, chat_id) for symbol in symbols]
        await asyncio.gather(*tasks)
        print("Sleeping for 5 minutes...")
        await asyncio.sleep(300)  # Sleep for 5 minutes before checking again

if __name__ == "__main__":
    asyncio.run(main())
