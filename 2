import ccxt
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import asyncio
import schedule
import time
from telegram import Bot
from telegram.error import TelegramError
from scipy.signal import argrelextrema
import config

def fetch_binance_data(symbol, timeframe='1h', limit=100):
    try:
        binance = ccxt.binance()
        ohlcv = binance.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        data = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        data['timestamp'] = pd.to_datetime(data['timestamp'], unit='ms')
        return data
    except Exception as e:
        print(f"Error fetching data for {symbol}: {e}")
        return pd.DataFrame()

def calculate_trendlines(data, ignore_last=5):
    data['high'] = data['high'].astype(float)
    data['low'] = data['low'].astype(float)

    window_size = 10
    valid_data = data.iloc[:-ignore_last].copy()  # Ignore the last few candles and create a copy
    valid_data['peaks'] = valid_data.iloc[argrelextrema(valid_data['high'].values, np.greater_equal, order=window_size)[0]]['high']
    valid_data['troughs'] = valid_data.iloc[argrelextrema(valid_data['low'].values, np.less_equal, order=window_size)[0]]['low']

    peaks = valid_data.dropna(subset=['peaks'])
    troughs = valid_data.dropna(subset=['troughs'])

    if len(peaks) < 2 or len(troughs) < 2:
        return None, None

    x_peaks = peaks.index.values[-2:]
    y_peaks = peaks['peaks'].values[-2:]
    fit_peaks = np.polyfit(x_peaks, y_peaks, 1)
    trendline_peaks = np.polyval(fit_peaks, np.arange(len(data)))

    x_troughs = troughs.index.values[-2:]
    y_troughs = troughs['troughs'].values[-2:]
    fit_troughs = np.polyfit(x_troughs, y_troughs, 1)
    trendline_troughs = np.polyval(fit_troughs, np.arange(len(data)))

    return trendline_peaks, trendline_troughs

def detect_breakout_breakdown(data, trendline_peaks, trendline_troughs):
    breakout = data[data['close'] > trendline_peaks]
    breakdown = data[data['close'] < trendline_troughs]
    return breakout, breakdown

def plot_trendlines(data, trendline_peaks, trendline_troughs, breakout, breakdown, symbol, filename):
    plt.figure(figsize=(12, 6))
    plt.plot(data['timestamp'], data['close'], label='Close Price')
    plt.plot(data['timestamp'], trendline_peaks, label='Resistance Trendline', linestyle='--', color='red')
    plt.plot(data['timestamp'], trendline_troughs, label='Support Trendline', linestyle='--', color='green')
    plt.scatter(breakout['timestamp'], breakout['close'], color='blue', label='Breakout Points')
    plt.scatter(breakdown['timestamp'], breakdown['close'], color='orange', label='Breakdown Points')
    plt.xlabel('Timestamp')
    plt.ylabel('Price')
    plt.legend()
    plt.title(f'Triangle Breakout/Breakdown Detection for {symbol}')
    plt.savefig(filename)
    plt.show()

async def send_image_to_telegram(filename, token, chat_id):
    bot = Bot(token=token)
    try:
        with open(filename, 'rb') as photo:
            await bot.send_photo(chat_id=chat_id, photo=photo)
    except TelegramError as e:
        print(f"Error sending image to Telegram: {e}")

def check_for_breakouts_and_breakdowns(symbols, timeframe, token, chat_id):
    for symbol in symbols:
        data = fetch_binance_data(symbol, timeframe)
        if data.empty:
            print(f"No data fetched for {symbol}.")
            continue

        trendline_peaks, trendline_troughs = calculate_trendlines(data)
        if trendline_peaks is None or trendline_troughs is None:
            print(f"Not enough data to calculate trendlines for {symbol}.")
            continue

        breakout, breakdown = detect_breakout_breakdown(data, trendline_peaks, trendline_troughs)
        if not breakout.empty or not breakdown.empty:
            filename = f'triangle_breakout_breakdown_{symbol.replace("/", "_")}.png'
            plot_trendlines(data, trendline_peaks, trendline_troughs, breakout, breakdown, symbol, filename)
            asyncio.run(send_image_to_telegram(filename, token, chat_id))

def main():
    symbols = ['BTC/USDT', 'ETH/USDT']  # List of symbols
    timeframe = '1h'
    token = config.TELEGRAM_BOT_TOKEN
    chat_id = config.TELEGRAM_CHAT_ID

    schedule.every(15).minutes.do(check_for_breakouts_and_breakdowns, symbols, timeframe, token, chat_id)

    while True:
        schedule.run_pending()
        time.sleep(1)

if __name__ == "__main__":
    main()